<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parinfer - simpler Lisp editing</title>
  <meta name="description" content="Parinfer - simpler Lisp editing">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/fonts.css">
  <link rel="stylesheet" href="css/font-awesome-4.4.0.min.css">
  <link rel="stylesheet" href="codemirror/lib/codemirror.css">
  <link rel="stylesheet" href="css/lib/keys.css">
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/theme.css">
</head>
<body class="no-mathjax">

<div class="sidebar">
  <h1>Par<em>infer</em></h1>
  <div class="credits">
    원저 <a href="http://twitter.com/shaunlebron">@shaunlebron</a> |
    <a href="https://github.com/shaunlebron/parinfer">GitHub</a>
  </div>
  <div class="credits" lang="ko">
    번역
    <a href="https://medium.com/@hatemogi">@hatemogi</a> |
    <a href="https://github.com/hatemogi/parinfer">GitHub</a>
  </div>
  <div id="locale">Locale</div>
  <div id="toc">
    <span class="caption">building table of contents...</a>
  </div>
</div>

<div id="app">

<!------------------------------------------------------------------------------------>

<div class="wrapper only-mobile">
<section>
  <h1>Par<em>infer</em></h1>
  <div class="credits" lang="en">
    <a href="http://twitter.com/shaunlebron">@shaunlebron</a> |
    <a href="https://github.com/shaunlebron/parinfer">GitHub</a>
  </div>
  <div class="credits" lang="ko">
    번역 <a href="http://twitter.com/hatemogi">@hatemogi</a> |
    <a href="https://github.com/hatemogi/parinfer">GitHub</a>
  </div>

<div class="interact" lang="en">
<i class="fa fa-desktop fa-lg"></i>
<strong>Best viewed</strong> on wide desktop browsers.  Sorry for the inconvenience.
</div>

<div class="interact" lang="ko">
<i class="fa fa-desktop fa-lg"></i>
데스크탑 브라우저에 <strong>최적화돼</strong> 있습니다. 양해 바랍니다.
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section>
<p class="subtitle" lang="en">
Let's simplify the way we write Lisp...
</p>
<p class="subtitle" lang="ko">
리스프 코드 작성법을 단순하게 해보죠...
</p>

<div class="interact" lang="en">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Interrupt the animations below to try it for yourself. Click outside to restore it.
</div>
<div class="interact" lang="ko">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>직접 해봐요!</strong> 아래 애니메이션에 끼어들어 직접 써보세요. 바깥쪽을 클릭하면 원래대로 복구합니다.
</div>


<div>
<div class="caption" lang="en"><strong>Parinfer's "Indent Mode"</strong> rearranges parens when you change indentation:</div>
<div class="caption" lang="ko"><strong>Parinfer의 "들여쓰기 모드"(Indent Mode)</strong>는 여러분이 들여쓰기를 바꾸는대로 괄호를 재정렬합니다.</div>
<textarea id="code-intro-indent">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Insert or delete a line</strong> without rearranging parens:</div>
<div class="caption" lang="ko">괄호는 건드리지 말고, <strong>한 줄을 추가하거나 삭제</strong>해보세요:</div>
<textarea id="code-intro-insert">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Comment a line</strong> without rearranging parens:</div>
<div class="caption" lang="ko">괄호를 건드리지 말고, <strong>주석 처리</strong>해보세요:</div>
<textarea id="code-intro-comment">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Basic Paredit without hotkeys</strong> thanks to simple paren inference. (wrap, splice, slurp, barf)</div>
<div class="caption" lang="ko">괄호추정 기능 덕분에 <strong>별도 단축키 없이도 Paredit의 기본 기능</strong>(wrap, splice, slurp, barf)을 쓸 수 있어요.</div>
<textarea id="code-intro-paredit">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Preserve indentation</strong> when editing in "Paren Mode":</div>
<div class="caption" lang="ko">"괄호 모드"(Paren Mode)는 <strong>들여쓰기를 유지</strong>한 채 편집합니다:</div>
<textarea id="code-intro-paren">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper fold">
<section>

<p lang="en">
<span class="title">Parinfer</span> is a proof-of-concept editor mode for Lisp
programming languages.  It simplifies the way we write Lisp by auto-adjusting
parens when indentation changes and vice versa. The hope is to make basic
Lisp-editing easier for newcomers and experts alike, while still allowing
existing plugins like Paredit to satisfy the need for more advanced operations.
</p>
<p lang="ko">
<span class="title">Parinfer</span>는 리스프 프로그래밍 언어를 위한 개념 증명 단계의 에디터 모드입니다.
리스프 코드를 작성할 때, 들여쓰기를 바꾸면 괄호를 자동으로 맞춰주며 그 반대로도 작동합니다.
리스프 입문자들도 전문가처럼 코드를 작성하기 쉽게 해주면서도, Paredit 같은 기존 플러그인의 고급 기능도 쓸 수 있습니다.
</p>

<ul lang="en">
  <li>Source code: <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a><br>
  <li>Created by: <a href="http://twitter.com/shaunlebron">@shaunlebron</a><br>
  <li>Download (work in progress): <a href="#editor-plugins">Editor Plugins</a>
</ul>
<ul lang="ko">
  <li>소스 코드: <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a><br>
  <li>작성자: <a href="http://twitter.com/shaunlebron">@shaunlebron</a><br>
  <li>번역: <a href="http://twitter.com/hatemogi">@hatemogi</a><br>
  <li>다운로드 (개발중): <a href="#editor-plugins">각종 에디터 플러그인</a>
</ul>

<div class="interact" lang="en">
<i class="fa fa-book fa-lg"></i>
<strong>Read on</strong> for a full exploration of the motivations, rules, and effects of Parinfer.
</div>
<div class="interact" lang="ko">
<i class="fa fa-book fa-lg"></i>
Parinfer의 동기, 규칙, 효과를 더 자세히 알아보시려면 <strong>계속 읽어주세요</strong>.
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="introduction">
<h2 lang="en">Introduction</h2>
<h2 lang="ko">소개</h2>

<p lang="en">
<strong>Lisp is often dismissed</strong> as an undesirable programming syntax
due to excessive parentheses.  Those who have adopted Lisp have long recognized its
amazing strengths, but there is still a widely held uncertainty among newcomers about
how or even <em>why</em> we must manage so many parens.  As a result, Lisp's
unique power remains invisible to most under this guise of difficulty.
</p>

<p lang="ko">
<strong>리스프는 흔히 무시되는데</strong>, 괄호가 너무 많은 프로그래밍 문법이 불편해 보이기 때문입니다.
리스프를 이미 쓰고 있는 개발자들이야 그 놀라운 강력함을 인식하지만, 새로 입문하는 사람들은 어떻게, 그리고 당최
<em>왜</em> 그 많은 괄호들을 다뤄야만 하는지 이해하기 어렵습니다. 그런 이유로, 리스프의 독특한 강점은
어려워 보이는 겉모습에 가려져 잘 드러나지 않고 있습니다.
</p>

<p lang="en">
<strong>Newcomers aren't satisfied</strong> with the current tools designed for
editing Lisp.  Expert-level editors (Emacs, Vim) and advanced hotkeys (Paredit)
are powerful but steepen the learning curve.  And alternative syntaxes (Lisps
without parens) have faltered since they sacrifice some of Lisp's power that
seasoned users aren't willing to part with.
</p>

<p lang="ko">
<strong>입문자들은 기존 리스프 편집툴들에 불만입니다.</strong>
전문가 수준의 에디터(Emacs, Vim)와 고급 단축키 (Paredit)는 강력하지만 배우기 어렵습니다.
그렇다고 (리스프의 괄호를 배제한) 대안 문법을 쓰자니 리스프에 익숙한 사람들이 포기할 수 없는 강력한 부분을 희생해야 하기 때문에 망설여집니다.
</p>

<p lang="en">
<strong>Parinfer is a new system</strong> that tries instead to fix this
problem at its source.  We formally define the relationship between Parens and
Indentation. With it, we create an intuitive editor mode to make paren
management fun and easy without sacrificing power.  We demonstrate this through
interactive proof-of-concept demos here, providing capabilities for:
</p>

<p lang="ko">
<strong>Parinfer는 이 문제의 근원부터 해결하고자 하는 새로운 시스템</strong>입니다.
우리는 괄호와 들여쓰기의 관계를 공식으로 정의합니다. 그 공식을 바탕으로 편집기 모드를 만들어서
괄호의 강력함을 포기하지 않고도 괄호를 재밌고 쉽게 다룰 수 있도록 합니다.
여기서 직접 체험하는 데모를 통해, 아래 기능을 보여드리겠습니다:
</p>

<ul lang="en" class="features">
<li> making code auto-adhere to formatting conventions
<li> influencing expression-nesting with indentation
<li> maintaining indentation when expressions shift
<li> allowing
<a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit</a>-like
features without hotkeys
</ul>

<ul lang="ko" class="features">
<li> 코드가 들여쓰기 규칙을 자동으로 지킵니다
<li> 중첩되는 식을 들여쓰기로 자동으로 조정합니다
<li> 식이 밀리거나 당겨지면 자동으로 들여쓰기를 유지합니다
<li>
<a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit</a>의 기능을 단축키 없이도 쓸 수 있습니다.
</ul>

<blockquote class="aside" lang="en">
<p>
<strong>NOTE: When I say "parens"</strong> (parentheses), I also mean <em>[square]</em> or <em>{curly}</em>
brackets.  Some Lisps (e.g.
<a href="http://racket-lang.org/">Racket</a>,
<a href="http://clojure.org/">Clojure</a>)
use these extra delimiters to help visually separate certain constructs.
</p>
</blockquote>

<blockquote class="aside" lang="ko">
<p>
<strong>알림: 여기서 "괄호"</strong>라 함은, <em>[대괄호]</em>나 <em>{중괄호}</em>
를 포함합니다.  몇몇 리스프 (예. <a href="http://racket-lang.org/">Racket</a>,
<a href="http://clojure.org/">Clojure</a>)는 이런 추가적인 괄호들을 써서 일부 언어의 구성 요소들을 구분하기 쉽게 합니다.
</p>
</blockquote>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="uncovering-lisp">
<h3 lang="en">Uncovering Lisp</h3>
<h3 lang="ko">리스프의 모든 것</h3>

<p lang="en">
Most programming languages have several syntax rules.  Lisp has one:
everything is a list.  The first element is a function name, and the rest are
its arguments.  Thus, the language is simply a collection of compile- and
run-time functions, trivially extensible.
</p>

<p lang="ko">
대부분의 프로그래밍 언어에는 많은 문법 규칙이 있습니다. 리스프는 단 하나의 규칙이 있어요: 모든 것이 리스트입니다.
리스트의 첫번째 요소는 함수의 이름이고, 나머지는 인수입니다. 그래서, 언어 전체가 단순히 컴파일할 때나 실행할 때의
함수들의 모음에 불과하고, 아주 간단하게 확장할 수 있습니다.
</p>

<div class="two-col">
<div class="col">
<div class="caption" lang="en"><strong>C Style</strong> expressions:</div>
<div class="caption" lang="ko"><strong>C 스타일</strong> 식:</div>
<textarea id="code-c-expr">
foo(1, 2, 3);
const a = 1;
if (a == 1) foo(); else bar();
const b = (a == 1) ? 2 : 3;
</textarea>
</div>

<div class="col">
<div class="caption" lang="en"><strong>Lisp Style</strong> expressions:</div>
<div class="caption" lang="ko"><strong>리스프 스타일</strong> 식:</div>
<textarea id="code-lisp-expr">
(foo 1 2 3)
(def a 1)
(if (= a 1) (foo) (bar))
(def b (if (= a 1) 2 3))
</textarea>
</div>
</div>

<p lang="en">
But parentheses in Lisp are infamous for bunching together at the end of long
expressions. This indentation
<a href="https://en.wikipedia.org/wiki/Indent_style#Lisp_style">convention</a>
can be jarring at first if you are used to curly braces in other languages
being on their own lines:
</p>

<p lang="ko">
하지만, 리스프는 긴 식의 마지막에 괄호가 잔뜩 뭉쳐 있기로 악명 높지요. 이런 들여쓰기
<a href="https://en.wikipedia.org/wiki/Indent_style#Lisp_style">관습</a>은
처음에 보기에, 다른 언어들에서 중괄호들이 한 줄씩 차지하는 것에 익숙했던 분들에게는, 거슬릴 수 있습니다:
</p>

<div class="two-col">
<div class="col">
<div class="caption" lang="en"><strong>C Style</strong> indentation (unusual in Lisp):</div>
<div class="caption" lang="ko"><strong>C 스타일</strong> 들여쓰기 (리스프에서는 흔치 않음):</div>
<textarea id="code-c-indent">
(defn foo [a b]
  (let [
     x (+ a b)
    ]
    (println "The sum is" x)
  )
)
</textarea>
</div>

<div class="col">
<div class="caption" lang="en"><strong>Lisp Style</strong> indentation:</div>
<div class="caption" lang="ko"><strong>리스프 스타일</strong> 들여쓰기:</div>
<textarea id="code-lisp-indent">
(defn foo [a b]
  (let [x (+ a b)]
    (println "The sum is" x)))
</textarea>
</div>
</div>

<p lang="en">
The idea behind this convention is to make every line inform with content
rather than just parens. Readability is helped by employing a Python-like
indentation style.  This achieves a sort of balance&mdash; Indentation allows
you to <em>skim</em> while the parens allow you to <em>inspect</em>:</p>

<p lang="ko">
이런 관습에는 각 줄에 단순한 괄호 이상으로 내용에 대한 정보를 제공하겠다는 뜻이 있습니다.
파이썬 방식의 들여쓰기로 가독성을 높일 수 있어요. 이렇게하면 일종의 균형이 잡히죠&mdash; 들여쓰기는 전체를 <em>대략 살펴보기</em> 좋게 해주면서도, 괄호로 <em>자세히 관찰하기 좋지요</em>:</p>

<div class="two-col">
<div class="col">
<div class="caption" lang="en"><strong>Skim</strong> by focusing on indentation</div>
<div class="caption" lang="ko">들여쓰기에 집중하며 <strong>대충 보세요</strong></div>
<textarea id="code-skim">
(defn foo [a b]
  (let [x (+ a b)]
    (println "The sum is" x)))
</textarea>
</div>

<div class="col">
<div class="caption" lang="en"><strong>Inspect</strong> parens with your cursor when needed</div>
<div class="caption" lang="ko">필요하면 괄호로 커서를 옮겨서 <strong>관찰합니다</strong></div>
<textarea id="code-inspect">
(defn foo [a b]
  (let [x (+ a b)]
    (println "The sum is" x)))
</textarea>
</div>
</div>

<p lang="en">
Though both <em>perspectives</em> are visible at once, we must focus on one at
a time.  A
<a href="https://twitter.com/paulg/status/588511912331055104">LEGO analogy</a>
helps here. Imagine each list in the previous example as a LEGO block
stacked over its parent. Checking the sides to see the layers below is like
checking the parens at the end of a line.
</p>
<p lang="ko">
두 <em>관점</em>이 한꺼번에 잘 드러나지만, 한번에 하나씩 집중해야 합니다.
<a href="https://twitter.com/paulg/status/588511912331055104">LEGO 비유</a>가
도움이 되요. 위 예제의 각 리스트가 겹겹이 쌓인 하나의 레고 블록이라고 상상해보세요.
아래 각 층의 옆면을 살펴보는 것이 마치 각 줄 끝의 괄호를 살펴보는 것과 같습니다.
</p>

<div class="two-col">
<div class="col">
<div class="caption" lang="en"><strong>Indentation</strong> implies nesting.</div>
<div class="caption" lang="ko"><strong>들여쓰기</strong>가 중첩을 암시합니다.</div>
<img class="lego-img" src="img/lego-indent.png">
</div>

<div class="col">
<div class="caption" lang="en"><strong>Tilting</strong> clarifies nesting (close-parens shown).</div>
<div class="caption" lang="ko"><strong>기울여 보면</strong> 중첩이 명백합니다 (닫는 괄호로 표시).</div>
<img class="lego-img" src="img/lego-parens.png">
</div>
</div>

<p lang="en">
This is a physical analog to the way we read Lisp code.  Now let's look at the
space of tooling solutions that we use for <em>writing</em> Lisp code and
specifically how Parinfer can help.
</p>
<p lang="ko">
이건 우리가 리스프 코드를 읽는 방법을 물리적으로 비유한 거죠. 이제 우리가 리스프 코드를 <em>작성하는</em> 데 쓰는 툴의 영역을 살펴보면서 어떻게 Parinfer가 도움이 될 건지 알아보겠습니다.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="tools-for-writing-lisp">
<h3 lang="en">Tools for Writing Lisp</h3>
<h3 lang="ko">리스프 작성 툴</h3>

<p lang="en">
In the previous section, we saw how Parens and Indentation provide two
perspectives for reading Lisp code.  Unfortunately, this incurs some redundancy
when <em>writing</em> Lisp since we must edit both for every change, ensuring
that one will correctly imply the other.
</p>
<p lang="ko">
이제까지, 어떻게 괄호와 들여쓰기가 리스프 코드를 읽는 두 관점을 지원하는지 보았습니다.
안타깝게도, 이 방식으로 리스프 코드를 <em>작성</em>할 때는, 무언가 바꿀 때마다 괄호와
들여쓰기가 서로 잘 대응하게끔 둘 다 편집해야 하는 중복 작업이 필요합니다.
</p>

<p lang="en">
There are existing tools to help with this.  To best represent how Parinfer
compares to them, we will represent this complex space of tooling in a way that
can be visually compared below.
</p>
<p lang="ko">
이런 작업을 도와주는 기존 툴들이 있습니다. Parinfer가 다른 툴들과 어떻게 다른지 잘 표현하기 위해, 아래처럼 시각적인 비유를 들어보겠습니다.
</p>

<div class="interact" lang="en">
<i class="fa fa-gear fa-lg"></i>
<strong>The black gear</strong> represents the current action we are taking.
</div>
<div class="interact" lang="ko">
<i class="fa fa-gear fa-lg"></i>
<strong>검은 톱니바퀴</strong>가 지금 우리가 하는 행위를 나타냅니다.
</div>

<p lang="en">
<strong>The menial and default</strong> way to edit Lisp is to manually ensure
our parens are balanced after inserting or removing them.  Then, we adjust the
indentation to match it in kind.  This back-and-forth happens for most editing
tasks.
</p>
<p lang="ko">
리스프 코드를 편집하는 <strong>지루하고 기본적인</strong> 방법은 괄호를 넣거나 빼고난 뒤에 균형이 잘 맞았는지 일일이 확인하는 것입니다. 그러고나서 들여쓰기를 조정하지요. 이런 앞뒤로 왔다 갔다 해야하는 일이 대부분의 편집 작업에 일어납니다.
</p>

<div class="gearbox" id="naive-gears">
</div>

<p lang="en">
<strong>Existing tools automate</strong> some of these editing tasks.
For example, <em>Paredit</em> forces you to transform or add parens in a
balanced way through special hotkeys.  And <em>Auto-indent</em> allows you to
auto-correct indentation of selected lines when desired.  This automates
the tasks, but the back-and-forth actions are still manually triggered.</p>

<p lang="ko">
이 작업의 일부를 <strong>기존 툴들이 자동으로</strong> 해줍니다. 예를 들어,  <em>Paredit</em>는 특별한 단축키를 써서 괄호의 위치를 바꾸거나 추가하는 일의 균형을 잡아줍니다. 그리고, <em>Auto-indent</em>는 원하는 선택영역의 들여쓰기를 자동으로 고쳐줍니다. 이런 왔다갔다 하는 작업을 자동으로 해주기는 하지만, 여전히 수동으로 지시해야 하지요.</p>

<div class="gearbox" id="helper-gears">
</div>

<p lang="en">
<strong>Parinfer is a new tool to <em>combine and simplify</em></strong> this
type of automation by naturally keeping Parens and Indentation in lockstep.  It
formally <em>infers</em> changes to one based on the other.  The back-and-forth
actions have been reduced with special modes, which we will explore next.
</p>
<p lang="ko">
<strong>Parinfer는 괄호와 들여쓰기 작업을 한꺼번에 자연스럽게 <em>합쳐서 단순화</em></strong>한 새로운 툴입니다. 공식을 써서 한쪽에서 작업이 일어나면 다른쪽을 어떻게 바꿔야하는지  <em>추정</em>합니다. 다음부터 살펴볼 특별한 모드들이 이 오며가며 해야하는 일들을 줄여줍니다.
</p>

<div class="gearbox" id="parinfer-gears">
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="writing-with-parinfer">
<h3 lang="en">Writing with Parinfer</h3>

<p lang="en">
As we saw with the previous visualization, Parinfer will infer some changes to
keep Parens and Indentation inline with one another.  To keep this inference
simple and predictable, we have the user explicitly choose the degree of
freedom that <em>they</em> want full control of, while relinquishing some
control of the other to <em>Parinfer</em>.
</p>
<p lang="ko">
앞선 시각화로 보았듯, 괄호와 띄어쓰기가 잘 맞도록 바꿔야 할 내용을 Parinfer가 추정합니다. 간단하고 예측할 수 있게 추정하기 위해, 우리는 <em>Parinfer</em>가 나머지 작업들을 어느 정도 알아서 하게 하면서도, <em>사용자</em>가 통제하고 싶은 정도를 명시적으로 선택할 수 있게했습니다.
</p>

<p lang="en">
Thus, Parinfer consists of two modes:
</p>
<p lang="ko">
그래서, Parinfer에는 두 가지 모드가 있습니다:
</p>

<ol>
<li lang="en">
<strong>Indent Mode</strong> gives you full control of indentation, while
Parinfer corrects parens.<br>
</li>
<li lang="ko">
<strong>들여쓰기 모드(Indent Mode)</strong>는 여러분이 들여쓰기를 직접 처리하고, Parinfer가 괄호를 알아서 고치도록 합니다.<br>
</li>
<li lang="en">
<strong>Paren Mode</strong> gives you full control of parens, while Parinfer
corrects indentation.<br>
</li>
<li lang="ko">
<strong>괄호 모드(Paren Mode)</strong>는 여러분이 괄호를 원하는대로 작성하고, Parinfer가 들여쓰기를 알아서 수정합니다.<br>
</li>
</ol>

<div class="interact" lang="en">
<i class="fa fa-lightbulb-o fa-lg"></i>
<strong>To make this easier</strong>, Indent Mode is default. Paren Mode can be an advanced option.
</div>
<div class="interact" lang="ko">
<i class="fa fa-lightbulb-o fa-lg"></i>
<strong>간단히 말하면</strong>, 들여쓰기 모드(Indent Mode)가 기본이고. 괄호 모드(Paren Mode)는 고급 기능입니다.
</div>

<p lang="en">
Some noteworthy unintended use-cases which we will explore later:
</p>
<p lang="ko">
의도한 것은 아니지만 언급할 가치가 있는 아래 용례를 잠시 후 살펴보겠습니다:
</p>

<ul>
  <li lang="en">Indent Mode allows Paredit-like features without hotkeys.</li>
  <li lang="ko">들여쓰기 모드는 Paredit의 기능들을 별도 단축키 없이도 쓸 수 있게 해줍니다.</li>
  <li lang="en">Paren Mode can be used to fix incorrectly indented files before using with Indent Mode.</li>
  <li lang="ko">괄호 모드를 들여쓰기가 잘못된 파일을 고치는데 쓰고나서 들여쓰기 모드를 쓸 수 있습니다.</li>
</ul>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="mathematical-foundation">
<h3 lang="en">Mathematical Foundation</h3>
<h3 lang="ko">수학적 기반</h3>

<div class="interact" lang="en">
<i class="fa fa-rocket fa-lg"></i>
<strong>Feel free to <a href="#indent-mode">skip this</a></strong> if you have no interest in the math that makes Parinfer possible.
</div>
<div class="interact" lang="ko">
<i class="fa fa-rocket fa-lg"></i>
Parinfer의 수학적 바탕에 관심이 없다면 편하게 <strong><a href="#indent-mode">건너뛰어</a></strong> 읽어주세요.
</div>

<p lang="en">
The foundation of Parinfer relies on a few somewhat formalized definitions and
properties:
</p>
<p lang="ko">
Parinfer의 기초는 어느정도 정형화해 정의한 공식과 속성에 기반합니다:
</p>

<div class="math-page mathjax">
<p lang="en">
We wish to define properties that each Parinfer mode should exhibit.
</p>
<p lang="ko">
각 Parinfer 모드가 지켜야 하는 속성들을 정의하고자 합니다.
</p>

<p lang="en">
With the following definitions:
<ul>
  <li>$I$ = (Indent Mode) function accepting code text and returning new text.</li>
  <li>$P$ = (Paren Mode) function accepting code text and returning new text.</li>
  <li>$R$ = (Reader) function accepting code text and returning its AST data.</li>
</ul>
</p>
<p lang="ko">
이하 정의에서:
<ul>
  <li>$I$ = (들여쓰기 모드) 함수는 코드 텍스트를 받아서 새 텍스트를 반환한다.</li>
  <li>$P$ = (괄호 모드) 함수는 코드 텍스트를 받아서 새 텍스트를 반환한다.</li>
  <li>$R$ = (읽기) 함수는 코드 텍스트를 받아서 그 코드의 AST 데이터를 반환한다.</li>
</ul>
</p>

<p lang="en">
The following should be true:
<ul>
  <li>let $y = P(x)$
        <div class="side-note">
          $\leftarrow$ run Paren-Mode on $x$ to get $y$
        </div>
    <ul>
      <li>$\Longrightarrow R(x) = R(y)$
        <div class="side-note">
          $\leftarrow$ Paren-Mode should never change the AST
        </div>
      <li>$\Longrightarrow P(y) = y$
        <div class="side-note">
          $\leftarrow$ Paren-Mode should be idempotent
        </div>
      <li>$\Longrightarrow I(y) = y$
        <div class="side-note">
          $\leftarrow$ Indent-Mode should never change the result of Paren-Mode
        </div>
    </ul>
</ul>
<p lang="ko">
아래가 참이어야합니다:
<ul>
  <li>let $y = P(x)$
        <div class="side-note">
          $\leftarrow$ $x$에 괄호 모드를 적용해서 $y$를 구할 때
        </div>
    <ul>
      <li>$\Longrightarrow R(x) = R(y)$
        <div class="side-note">
          $\leftarrow$ 괄호 모드가 AST를 바꾸지 않는다.
        </div>
      <li>$\Longrightarrow P(y) = y$
        <div class="side-note">
          $\leftarrow$ 괄호 모드를 여러번 적용해도 같다(idempotent).
        </div>
      <li>$\Longrightarrow I(y) = y$
        <div class="side-note">
          $\leftarrow$ 들여쓰기 모드가 괄호 모드의 결과를 바꿔서는 안된다
        </div>
    </ul>
</ul>

<ul>
  <li>let $z = I(x)$
        <div class="side-note">
          $\leftarrow$ $x$에 들여쓰기모드를 적용해서 $z$를 구할 때
        </div>
    <ul>
      <li>$\mathrel{\rlap{\hskip .5em/}}\Longrightarrow R(x) = R(z)$
        <div class="side-note">
          $\leftarrow$ 들여쓰기 모드가 AST를 바꿀 수도 있다 (의도한 것)
        </div>
      <li>$\Longrightarrow I(z) = z$
        <div class="side-note">
          $\leftarrow$ 들여쓰기 모드는 여러번 적용해도 같다(idempotent)
        </div>
    </ul>
</ul>
</p>

</div>

<p class="mathjax" lang="en">
The actual operations performed by the modes rely on a formal definition
of what it means for Lisp code to be "correctly formatted".  We establish an
invariant&mdash; something that must be true for every line of code.  From that,
Parinfer corrects indentation or parens simply by choosing correct values for
$i_n$ or $p_n$ (defined later) to satisfy this invariant:
</p>

<p class="mathjax" lang="ko">
두 모드가 처리하는 작업은 리스프 코드로서 옳바른 포맷이도록 하는 정의에 의존합니다.
우리는 코드의 매 라인에 대해 항상 참인 불변식을 작성해서 $i_n$ 또는 $p_n$ (잠시 후 정의)를
선택하는 간단한 작업만으로도 Parinfer가 들여쓰기나 괄호를 수정할 수 있도록 하는데, 그 불변식은 다음과 같습니다:
</p>

<ul class="mathjax" lang="en">
  <li><strong>Indent Mode</strong> forces correct values of $p_n$</li>
  <li><strong>Paren Mode</strong> forces correct values of $i_n$</li>
</ul>
<ul class="mathjax" lang="ko">
  <li><strong>들여쓰기 모드</strong>는 $p_n$의 옳은 값을 강제한다</li>
  <li><strong>괄호 모드</strong>는 $i_n$의 옳은 값을 강제한다</li>
</ul>

<p lang="en">
The following is a concise reference (not a guide) to establishing this
invariant that Parinfer's modes rely on.
</p>
<p lang="ko">
아래는 두 Parinfer 모드가 바탕으로 삼는 명시적 참조 (가이드는 아님)입니다.
</p>

<div class="math-page mathjax">
<p lang="en">
We wish to define necessary conditions for determining if a given file of Lisp
code is "correctly formatted".
</p>
<p lang="ko">
주어진 파일의 리스프 코드가 "형식에 맞게 작성"됐다고 여기는데 필요한 조건을 정의하고자 한다.
</p>

<p lang="en">
We start with a clarification that we only consider non-empty lines (i.e. lines
that have at least one non-whitespace, non-comment token).  Thus, all following
references to line number $n$ will refer to the $n$th non-empty line.
</p>
<p lang="ko">
여기서는 내용이 있는 라인들(공백문자나 주석이 아닌 무언가가 하나라도 있는 라인들)만을 고려한다. 즉, 줄번호 $n$은 $n$번째 빈줄 아닌 라인을 가르킨다.
</p>

<p lang="en">
To proceed, we define the following:

<ul>
<li>
$t_n$ = (tokens) index of non-whitespace, non-comment tokens at line $n$
</li>
<li>
$i_n$ = (indentation) x-position of $t_n[0]$
</li>
<li>
$p_n$ = (parens) number of close-parens at the end of $t_n$
</li>
<li>
$s_n$ = (stack) index of x-positions of all open-parens unclosed before $t_n[-p_n]$
</li>
</ul>
</p>
<p lang="ko">
아래를 정의하고 계속하자:

<ul>
<li>
$t_n$ = (tokens) $n$째 줄의 비공백, 비주석 토큰의 인덱스
</li>
<li>
$i_n$ = (indentation) $t_n[0]$의 x좌표
</li>
<li>
$p_n$ = (parens) $t_n$의 끝에 있는 닫는 괄호의 수
</li>
<li>
$s_n$ = (stack) $t_n[-p_n]$에 앞서 닫히지 않은 모든 괄호의 x좌표들 전부
</li>
</ul>
</p>

<p lang="en">
Next, we define a function which determines if a line's indentation is valid:

<ul>
  <li>$f(i,p,s) = ( x_\text{min} \lt i \leq x_\text{max} )$
    <div class="side-note">$\leftarrow$ verifies indentation is within a threshold defined below</div>
  </li>
</ul>
</p>
<p lang="ko">
그리고, 특정 라인의 들여쓰기가 옳바른지 판단하는 함수를 정의하자:

<ul>
  <li>$f(i,p,s) = ( x_\text{최소} \lt i \leq x_\text{최대} )$
    <div class="side-note">$\leftarrow$ 아래 정의한 임계 안에서 들여쓰기가 잘 됐는지 검증</div>
  </li>
</ul>
</p>

<p lang="en">
where:
<ul>
  <li>$x_\text{min} = \begin{cases} s[-p-1] & \text{if } |s| > p, \\ -1 & \text{otherwise} \end{cases}$
    <div class="side-note">
      $\leftarrow$ x-position of open-paren of parent list if it exists
    </div>
  </li>
  <li>$x_\text{max} = \begin{cases} s[-p] & \text{if } p \gt 0, \\ \infty & \text{otherwise} \end{cases}$
    <div class="side-note">
      $\leftarrow$ x-position of open-paren of previous sibling if it is a list
    </div>
  </li>
</ul>
</p>
<p lang="ko">
where:
<ul>
  <li>$x_\text{최소} = \begin{cases} s[-p-1] & |s| > p\text{인 경우}, \\ -1 & \text{그 외} \end{cases}$
    <div class="side-note">
      $\leftarrow$ 상위의 리스트에 열린 괄호가 있다면 그 x좌표
    </div>
  </li>
  <li>$x_\text{최대} = \begin{cases} s[-p] & \text{만약 } p \gt 0인 경우, \\ \infty & \text{그 외} \end{cases}$
    <div class="side-note">
      $\leftarrow$ 앞선 형제가 있는데 리스트라면 그 리스트의 열린 괄호의 x좌표
    </div>
  </li>
</ul>
</p>


<p lang="en">
Finally, we define that a file of Lisp code is "correctly formatted" if:

<ol>
  <li>for every line $n > 0$:
    <ul>
      <li>$t_n[0] \ne $ ")", and
        <div class="side-note">
          $\leftarrow$ no line may start with a close-paren
        </div>
      </li>
      <li>$f(i_n, p_{n-1}, s_{n-1})$ is true
        <div class="side-note">
          $\leftarrow$ indentation threshold that we defined above
        </div>
      </li>
    </ul>
  </li>
  <li>and for the last line $N$
    <ul>
      <li>$|s_N| = p_N$
        <div class="side-note">
          $\leftarrow$ all open-parens must be closed at the last line
        </div>
      </li>
    </ul>
  </li>
</ol>
</p>
<p lang="ko">
마지막으로, 만약 이하의 조건이 성립하면 파일의 리스프 코드가 "옳은 형식"으로 되어있다고 정의한다:

<ol>
  <li>$n > 0$인 모든 라인에 대해:
    <ul>
      <li>$t_n[0] \ne $ ")", 이고
        <div class="side-note">
          $\leftarrow$ 닫는 괄호로 시작하는 라인이 없어야 한다
        </div>
      </li>
      <li>$f(i_n, p_{n-1}, s_{n-1})$ 이 참이다
        <div class="side-note">
          $\leftarrow$ 위에 정의한 들여쓰기 임계치
        </div>
      </li>
    </ul>
  </li>
  <li>그리고 마지막 라인 $N$에 대해
    <ul>
      <li>$|s_N| = p_N$
        <div class="side-note">
          $\leftarrow$ 열린 괄호모두가 마지막줄에 닫혀야 한다
        </div>
      </li>
    </ul>
  </li>
</ol>
</p>

</div>

<p lang="en">
These rules are necessary and sufficient for determining when indentation is
what we consider "unambiguous", but they are not sufficient in determining if
code is "pretty". For example:

<ul>
<li lang="en">single-line files are okay</li>
<li lang="en">"tab" lengths are flexible (one space, two spaces, etc)</li>
<li lang="en">indentation of sibling lines are not required to be aligned</li>
</ul>
</p>
<p lang="ko">
:TODO:
These rules are necessary and sufficient for determining when indentation is
what we consider "unambiguous", but they are not sufficient in determining if
code is "pretty". For example:

<ul>
<li lang="en">single-line files are okay</li>
<li lang="en">"tab" lengths are flexible (one space, two spaces, etc)</li>
<li lang="en">indentation of sibling lines are not required to be aligned</li>
</ul>
</p>

<p lang="en">
Formal descriptions of the actual operations performed by the modes are
pending, but informal ones follow in their respective sections below.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="indent-mode">
<h2 lang="en">Indent Mode</h2>

<p lang="en">
Indent Mode gives you full control of indentation, while Parinfer corrects or
inserts close-parens where appropriate.  Specifically, it only touches the
groups of close-parens at the end of each line.  As a visual cue, we
<em>slightly dim</em> these parens to signify their inferred nature.
</p>

<div class="interact" lang="en">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Interrupt the animations below to try it for yourself. Click outside to restore it.
</div>

<div>
<div class="caption" lang="en"><strong>Indent</strong> to influence the structure of your code:</div>
<textarea id="code-indent">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Indent further</strong> to reach different thresholds:</div>
<textarea id="code-indent-far">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Indent multiple lines</strong> to see its effect:</div>
<textarea id="code-indent-multi">
</textarea>
</div>

<p lang="en">
You can select multiple lines and adjust their indentation the standard way using
the controls below.  If you are familiar with Paredit, these operations are
roughly equivalent to those listed.
</p>

<table class="paredit-table" lang="en">
<tr>
<th>Controls</th>
<th>Description</th>
<th>Paredit equivalent</th>
</tr>
<tr>
<td><kbd class="light">Tab</kbd></td>
<td>indent line(s)</td>
<td>slurp line(s) down</td>
</tr>
<tr>
<td><kbd class="light">Shift</kbd> + <kbd class="light">Tab</kbd></td>
<td>dedent line(s)</td>
<td>barf line(s) down</td>
</tr>
</table>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="interesting-consequences">
<h3 lang="en">Interesting Consequences</h3>

<div lang="en">
<div class="caption"><strong>Insert or delete a line</strong> without rearranging parens:</div>
<textarea id="code-line">
</textarea>
</div>

<div lang="en">
<div class="caption"><strong>Comment a line</strong> without rearranging parens:</div>
<textarea id="code-comment">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="indent-how-it-works">
<h3 lang="en">How it works</h3>

<p lang="en">
We perform the following steps to rearrange close-parens based on indentation.<br>
<span class="side-point">We will refer to these later as rules #1, #2, #3 and #4.</span>
</p>

<ol>
<li lang="en"> <span class="removed">remove</span> all unmatched close-parens (for housekeeping)
<li lang="en"> <span class="removed">remove</span> all close-parens at the start and end of each line
<li lang="en"> <span class="kept">keep</span> all close-parens <em>inside</em> each line
<li lang="en"> for every resulting unmatched open-paren:
  <ul>
  <li lang="en"> <span class="inserted">insert</span> a matching close-paren at the end of its line or its last non-empty indented line
  </ul>
</ol>

<div class="interact" lang="en">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Edit the code below on the left to see how parens are inferred on the right.
</div>


<div class="two-col">
<div class="col">
<div class="caption" lang="en"><strong>Input:</strong> close-parens are removed or kept.</div>
<textarea id="code-indent-input">
(defn on-click []
  (swap! s update-in [:x] inc)
  )

(defn component
  "my docstring."
  [messages]
  [:div]
   (for [[i msg] messages]
     [:div msg])
  )
</textarea>
</div>

<div class="col" lang="en">
<div class="caption"><strong>Output:</strong> close-parens are inserted.</div>
<textarea id="code-indent-output">
</textarea>
</div>
</div>

<p lang="en">
This is the gist of what's happening.  There are more steps performed, but we
will just explore their effects in the next section.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="paredit-emerges">
<h3 lang="en">Paredit emerges</h3>

<p lang="en">
You should be aware that the steps in the previous section have a side effect on
what you type.  Interestingly, these effects translate into four of the main
<a href="">Paredit</a>
 operations.
</p>

<table class="paredit-table light-keys">
<tr lang="en">
<th align="right">Cause</th>
<th align="center">Effect</th>
<th align="left">Description</th>
</tr>

<tr lang="en">
<td align="right">Insert <kbd>(</kbd></td>
<td align="center">Wrap</td>
<td align="left">
inserts a matching <kbd>)</kbd> as far as it can
<div class="side-point">
i.e. "wraps" all possible elements to the right of your cursor
</div>
</td>
</tr>

<tr lang="en">
<td align="right" lang="en">Insert <kbd>)</kbd></td>
<td align="center" lang="en">Barf</td>
<td align="left">
removes the original <kbd>)</kbd> when inserted inside a matching pair
<div class="side-point">
i.e. the current list "barfs" out all elements to the right of your cursor
</div>
</td>
</tr>

<tr lang="en" lang="en">
<td align="right">Delete <kbd>(</kbd></td>
<td align="center">Splice</td>
<td align="left">
removes the matching <kbd>)</kbd>
<div class="side-point">
i.e. "splices" the current list into its parent (or simply "unwraps" it)
</div>
</td>
</tr>

<tr lang="en">
<td align="right">Delete <kbd>)</kbd></td>
<td align="center">Slurp</td>
<td align="left">
inserts another <kbd>)</kbd> as far as it can
<div class="side-point">
i.e. the current list "slurps" all elements to the right of your cursor
</div>
</td>
</tr>

</table>

<p lang="en">
We illustrate these operations in the following examples.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="inserting-parens">
<h3 lang="en">Inserting Parens</h3>

<div>
<div class="caption" lang="en"><strong>Wrap</strong> by inserting an open-paren. It will auto-close as far as it can, due to rule #4.</div>
<textarea id="code-wrap">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Barf</strong> by inserting a close-paren before another.
Notice the original is removed, due to rule #1.</div>
<textarea id="code-barf">
</textarea>
</div>

<div class="caption" lang="en">
<div class="question">
<i class="fa fa-question-circle"></i>
Why can't I insert a close-paren in certain places?
</div>
<div class="answer">Its corresponding open-paren must be there first. (see rule #1)</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="deleting-parens">
<h3 lang="en">Deleting Parens</h3>

<div lang="en">
<div class="caption"><strong>Splice</strong> by removing an open-paren. Its corresponding close-paren is removed, due to rule #1.</div>
<textarea id="code-splice">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Slurp</strong> by deleting a close-paren inside a line. It is replaced further down, due to rule #4.</div>
<textarea id="code-slurp">
</textarea>
</div>

<div class="caption" lang="en">
<div class="question">
<i class="fa fa-question-circle"></i>
Why can't I delete a close-paren in certain places?
</div>
<div class="answer">You cannot delete an inferred close-paren. It is replaced as soon as you delete it. (see rule #4)</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="knowing-when-parens-move-in-indent-mode">
<h3 lang="en">Knowing When Parens Move</h3>

<p lang="en">
As a courtesy, <em>Indent Mode</em> will not move your parens until you are done typing
in front of them.  Just move your cursor away when you're done.  A helpful
analogy might be to think of your cursor as a <em>paperweight</em> that keeps your
parens from blowing away.
</p>

<div>
<div class="caption" lang="en"><strong>Paren displaced</strong> when your cursor moves to another line. (displaced due to indentation)</div>
<textarea id="code-displaced">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Paren not displaced</strong> since you were given the chance to block it. (paren not at end of line)</div>
<textarea id="code-not-displaced">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="pressing-enter">
<h3 lang="en">Pressing Enter</h3>

<p lang="en">
Pressing enter will result in your cursor moving to an auto-indented line, as
expected.  Just keep in mind that the inferred parens won't move until you
actually type something on the new line.
</p>

<div>
<div class="caption" lang="en">
<strong>Watch where the cursor is</strong> when pressing Enter. Inferred parens not displaced until typing. (rule #2)
</div>
<textarea id="code-enter">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="inserting-quotes">
<h3 lang="en">Inserting Quotes</h3>

<p lang="en">
<em>Parinfer</em> cannot infer anything about quote positions like it can with parens.
So it doesn't try to do anything special with them, other than abandon
processing if imbalanced quotes are detected.
</p>

<div>
<div class="caption" lang="en"><strong>Quote</strong> insertion allows temporary paren imbalances until quote is closed:</div>
<textarea id="code-string">
</textarea>
</div>

<div class="warning">
<div class="warning-title" lang="en">
<i class="fa fa-lg fa-warning"></i>
WARNING: Always make sure quotes are balanced when inside comments!
</div>
<div class="warning-body" lang="en">
If there is an unclosed quote before a comment, which itself contains
imbalanced quotes, they will balance each other out and fool <em>Parinfer</em> into
thinking it is okay for processing.
</div>
</div>

<div class="two-col">
<div class="col">
<div class="caption">
<i class="fa fa-lg fa-times red" lang="en"></i>
<strong>BAD:</strong> An unclosed string in a comment can cause corrupted strings.
</div>
<textarea id="code-warn-bad">
</textarea>
</div>

<div class="col">
<div class="caption" lang="en">
<i class="fa fa-lg fa-check green"></i>
<strong>GOOD</strong>: Balance the quotes in the comment to prevent the problem.
</div>
<textarea id="code-warn-good">
</textarea>
</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="paren-mode">
<h2 lang="en">Paren Mode</h2>

<p lang="en">
Paren Mode gives you full control of parens, while Parinfer corrects indentation.
You can still adjust indentation, but you won't be able indent/dedent past certain
boundaries set by parens on previous lines.  As a courtesy, this mode also
maintains relative indentation of child elements when their parent expressions
shift.
</p>

<p lang="en">
Here are some things that cannot be done in Indent Mode:
</p>

<div>
<div class="caption" lang="en"><strong>Tune indentation</strong> without worrying about crossing a paren boundary:</div>
<textarea id="code-paren-tune">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Avoid fracturing</strong> a multi-line expression when pushing its open-paren forward:</div>
<textarea id="code-paren-frac">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Indentation is maintained</strong> when parens shift, ensuring reversible operations:</div>
<textarea id="code-paren-comment">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Nested expressions</strong> become automatically indented (temporary imbalances allowed):</div>
<textarea id="code-paren-wrap">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="paren-how-it-works">
<h3 lang="en">How it works</h3>

<p lang="en">
Paren Mode performs the following steps:
</p>

<ol>
<li lang="en"> Move close-parens at the start of a line to the end of the previous non-empty line.
<li lang="en"> Clamp the indentation of a line to the following range:
  <ul>
    <li> min: x-position of the parent open-paren (if it exists)
    <li> max: x-position of the open-paren belonging to the previous non-empty line's last close-paren
  </ul>
<li lang="en"> Child elements of moved expressions should maintain their original relative indentation to them.
<li lang="en"> Cancel processing if there are any unmatched parens.
</ol>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="switching-modes">
<h3 lang="en">Switching Modes</h3>

<p lang="en">
If there are paren imbalances in Paren Mode, the code is not processed, and you
are prevented from switching to Indent Mode.  This safely quarantines the
imbalances that could be misinterpreted in Indent Mode.  Thus, Paren Mode gives
you an environment to fix them, after which the code is automatically formatted
and ready for Indent Mode should you choose to switch.
</section>
</div>
</p>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="fixing-existing-files">
<h3 lang="en">Fixing existing files</h3>

<p lang="en">
We must take parens literally when opening an existing file. Incidentally,
Paren Mode is perfect for this job, so we preprocess existing files with it
before allowing the switch to Indent Mode.
</p>

<div class="interact" lang="en">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Edit the code below on the left to see how it is formatted on the right.
</div>

<div class="two-col">
<div class="col">
<div class="caption" lang="en"><strong>Input:</strong> Any existing file. Must be correctly balanced, but can be incorrectly formatted.</div>
<textarea id="code-paren-input">
(defn foo
  ([a]
    (foo a 1))
  ([a b]
    (let [sum (+ a b)
          prod (* a b)
          result { ; gather vals
            :sum sum
            :prod prod
          }]
      result)
    ; TODO: something
    ))
</textarea>
</div>

<div class="col">
<div class="caption" lang="en"><strong>Output:</strong> Made ready for Parinfer by correcting indentation and moving close-parens.</div>
<textarea id="code-paren-output">
</textarea>
</div>
</div>

<p lang="en">
Notice that this process is NOT an invasive pretty-printer.  Newline characters
are never added or removed.  It preserves as much as it can of the original
code, only moving close-parens and changing indentation.
</p>

<p lang="en">
<em>Parinfer</em> should remain in Paren Mode if the file cannot be processed, due
to the reasons stated in the previous section.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="knowing-when-parens-move-in-paren-mode">
<h3 lang="en">Knowing When Parens Move</h3>

<p lang="en">
As a courtesy, <em>Paren Mode</em> will not move your parens while your cursor
is behind them. Just move your cursor away when you're done.  A helpful
analogy might be to think of your cursor as a <em>paperweight</em> that keeps
your parens from blowing away.
</p>

<div>
<div class="caption" lang="en"><strong>Parens displaced</strong> only after they are balanced.</div>
<textarea id="code-displaced-after-balance">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Parens not displaced</strong> if the cursor is behind it (allowing you to type).</div>
<textarea id="code-not-displaced-on-enter">
</textarea>
</div>

<div>
<div class="caption" lang="en"><strong>Parens displaced</strong> if the cursor is no longer behind them.</div>
<textarea id="code-displaced-after-cursor-leaves">
</textarea>
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="conclusions">
<h2 lang="en">Conclusions</h2>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="benefits">
<h3 lang="en">Benefits</h3>

<p lang="en">
Inferring parentheses based on indentation seems to lead to simpler editing
mechanics for Lisp code.  It leads to a system that keeps our code formatted
well. And it allows us to use paredit-like features without hotkeys.
</p>

<p lang="en">
I think the biggest win is its potential to quell fear of managing end-of-line
parens by enforcing a direct driving relationship with indentation.
</p>

<p lang="en">
And just like <em>Paredit</em> it maintains paren-balanced code.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="downsides">
<h3 lang="en">Downsides</h3>

<p lang="en">
The rules for what happens when inserting/deleting parens must be learned.
Also, the case necessitating a "Paren Mode" comes at the cost of forcing the
user to understand when and how to switch editing modes.
</p>

<p lang="en">
Also, the preprocessor step performed when opening files will cause more
formatting-related changes in your commit history when collaborating with
others not using <em>Parinfer</em>.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="final-thoughts">
<h3 lang="en">Final Thoughts</h3>

<p lang="en">
Regardless of how we choose to edit our Lisp code, there seems to always be a
balancing act between maintaining the simplicity of how we interact with the
editor and accepting some editor complexity to gain automation over these
powerful but numerous parens.
</p>

<p lang="en">
Building the interactive examples for this page has allowed me to explore how
well Parinfer can play this balancing act, but only in a demo environment.
The <em>real test</em> will come once it becomes available to major editors.
See <a href="#editor-plugins">editor plugins</a> for progress.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="appendix">
<h2>Appendix</h2>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="source-code">
<h3 lang="en">Source Code</h3>

<p lang="en">
The text formatting code is intended to be editor-agnostic.  It is implemented
in straightforward, imperative JavaScript, optimized for speed and designed
to be easy to port to other languages. There is a test suite which is also
designed to be easy to port with all test cases represented in JSON files.
</p>

<p lang="en">
The editor demos on this site are created in CodeMirror with hooks to apply our
formatters and update cursor position.  Source code for both the library and site
are available on github:
</p>

<p>
<i class="fa fa-lg fa-code-fork"></i> <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a>
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="editor-plugins">
<h3 lang="en">Editor Plugins</h3>

<p lang="en">
Parinfer is still in early development. Several people have started integrating
it into code editors at various stages of development.
</p>

<p lang="en">
<strong>Works in Progress:</strong>
</p>

<ul>
  <li>
    <a href="https://github.com/oakmac/atom-parinfer">atom-parinfer</a>
    for <a href="https://atom.io/">Atom</a>
  </li>
  <li>
    <a href="https://github.com/snoe/nvim-parinfer.js">nvim-parinfer.js</a>
    for <a href="https://neovim.io/">neovim</a>
  </li>
  <li>
    <a href="https://github.com/bhurlow/vim-parinfer">vim-parinfer</a>
    for <a href="http://www.vim.org/">Vim</a>
  </li>
  <li>
    <a href="https://github.com/Microsoft/vscode-parinfer">vscode-parinfer</a>
    for <a href="https://code.visualstudio.com/">Visual Studio Code</a>
  </li>
  <li>
    <a href="https://github.com/oakmac/sublime-text-parinfer">sublime-text-parinfer</a>
    for <a href="http://www.sublimetext.com/">Sublime Text</a>
  </li>
  <li>
    parinfer-mode
    <a href="https://github.com/edpaget/parinfer-mode">1</a> or
    <a href="https://github.com/DogLooksGood/parinfer-mode">2</a>
    for <a href="https://www.gnu.org/software/emacs/">Emacs</a>
  </li>
  <li>
    <a href="https://github.com/hiram-madelaine/codemirror-parinfer">codemirror-parinfer</a>
    for <a href="https://codemirror.net/">CodeMirror</a>
  </li>
  <li>
    <a href="https://github.com/mauricioszabo/lt_parinfer">lt_parinfer</a>
    for <a href="http://lighttable.com/">Light Table</a>
  </li>
  <li>
    native support in <a href="https://github.com/oakes/Nightcode">Nightcode</a>
  </li>
</ul>

<p lang="en">
Parinfer is available for some REPL environments as well:
</p>

<ul>
  <li>
    <a href="https://github.com/mfikes/replete">Replete</a> for iOS
  </li>
  <li>
    <a href="https://github.com/binaryage/dirac">Dirac DevTools</a> for Google Chrome
  </li>
  <li>
    <a href="http://jaredforsyth.com/reepl/">Reepl</a> for the browser
  </li>
</ul>

<div class="interact">
<i class="fa fa-commenting-o fa-flip-horizontal fa-lg"></i>
<a href="https://github.com/shaunlebron/parinfer/issues/new?title=new%20plugin">Let me know</a>
if you're working on a plugin, or
<a href="https://github.com/shaunlebron/parinfer/wiki/Make-a-Plugin">check the wiki</a>
for extra guidance.  Thanks!
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="acknowledgements">
<h3>Acknowledgements</h3>

<ul>

  <li>
    <a href="https://elpa.gnu.org/packages/adjust-parens.html">adjust-parens</a>
    is an earlier idea for adjusting close-parens based on indentation in Emacs.
  </li>

  <li>
    <a href="https://github.com/Malabarba/aggressive-indent-mode">aggressive-indent-mode</a>
    re-indents code after every keystroke in Emacs, to remove the back-and-forth actions mentioned
    in the <a href="#tools-for-writing-lisp">Tools for Writing Lisp</a> section.
    I believe Parinfer's Paren Mode is less aggressive in that it keeps
    indentation within thresholds rather than hard limits (more on this in a
    future section).
  </li>

  <li>
    <a href="http://haml.info">Haml</a>,
    <a href="http://slim-lang.com/">Slim</a>,
    <a href="http://jade-lang.com/">Jade</a> &mdash;
    comparing these indented-templating languages to Clojure's Hiccups is what
    made me realize Lisp close-parens could be inferred from indentation.
  </li>

  <li>
    Thanks to
    <a href="https://github.com/boxed">Anders Hovmöller</a> and
    <a href="https://github.com/darwin">Antonin Hildebrand</a> for humoring me on an
    <a href="https://github.com/boxed/indent-clj/issues/1">early crazy idea</a>
    and connecting me to some ideas about indentation and structural editors.
  </li>

  <li>
    <a href="http://readable.sourceforge.net/">sweet-expressions</a>,
    <a href="http://srfi.schemers.org/srfi-49/srfi-49.html">i-expressions</a>,
    <a href="https://github.com/boxed/indent-clj">indent-clj</a>, et al
    explored how parentheses can be inferred (but hidden).
  </li>

  <li>
    <a href="http://learnyouahaskell.com/higher-order-functions#function-application">Haskell's $ operator</a>
    infers a closing paren after all expressions to the right, even after
    subsequent indented expressions, which is basically what Indent Mode in
    Parinfer does.
  </li>

  <li>
    <a href="https://github.com/Cirru/sepal.clj">Cirru Sepal in Clojure</a>
    has an interesting approach to inferring Clojure parens from indentation
    and other syntax sugar&mdash; <code>$</code>, <code>$ []</code>, <code>$
    {}</code> and <code>,</code>.
  </li>

  <li>
    It's worth mentioning
    <a href="https://github.com/mkremins/flense">Flense</a>
    and
    <a href="https://github.com/darwin/plastic">Plastic</a>
    as tools with ambitious structural editing concepts for Clojure text.
  </li>

  <li>
    <a href="http://www.greenfoot.org/frames/">Frame-Based Editing</a> and
    <a href="https://scratch.mit.edu/">Scratch</a> remove parens (or curly braces)
    using blocks (like the LEGO metaphor mentioned).
  </li>

  <li>
    <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit animations</a>
    inspired the editor animations here.
  </li>

  <li>
    <a href="https://github.com/bbatsov/clojure-style-guide#source-code-layout--organization">The Clojure Style Guide</a>
    helped me confirm some indentation conventions when formalizing Parinfer.
  </li>

  <li>
    <a href="https://twitter.com/escherize">Bryan Maass</a>
    explained to me how Lisp is like Lego&mdash; everything being the same
    shape so they can snap together any way you see fit, while other syntaxes
    have different shaped pieces which only fit together in special ways.
  </li>

  <li>
    Thanks to
    <a href="http://chrisoakman.com/">Chris Oakman</a>
    for proof-reading this page, pushing me to make an efficient implementation
    of Indent Mode, and starting the
    <a href="https://github.com/oakmac/atom-parinfer">atom-parinfer</a>
    plugin.
  </li>

  <li>
    Thanks to my friends at PROS for looking at an early draft of this page.
  </li>

  <li>
    Thanks to the Clojure/ClojureScript community for making me fall in love
    with Lisp.
  </li>

  <li>
    When John Carmack adopted Lisp (Racket) for Oculus Rift scripting,
    it gave me a little more momentum to finish writing this!
  </li>

  <li>
    I used the really cool <a href="https://github.com/liabru/gears-d3-js">gears.d3.js</a>
    library for the animated gears here.
  </li>

  <li>
    I built Parinfer as an augmentation to the
    <a href="https://codemirror.net/">CodeMirror</a>
    editor, which I really enjoyed working with and studying to learn about
    editors.
  </li>

</ul>
</section>
</div>


<section>
<div id="xkcd">
<a href="https://xkcd.com/312/"><img src="img/xkcd-frost.png"></a>
</div>
</section>

<!------------------------------------------------------------------------------------>

</div><!-- end #app -->

<div id="controls-container"></div>

<script src="codemirror/lib/codemirror.js"></script>
<script src="codemirror/addon/selection/active-line.js"></script>
<script src="codemirror/addon/edit/matchbrackets.js"></script>
<script src="codemirror/mode/javascript/javascript.js"></script>
<script src="codemirror/mode/clojure/clojure.js"></script>
<script src="codemirror/mode/clojure/clojure-parinfer.js"></script>

<script src="js/lib/scrollMonitor.js"></script>

<script src="js/lib/d3-3.3.3.min.js"></script>
<script src="js/lib/gears.d3.js"></script>

<script src="js/lib/jsdiff.min.js"></script>
<script src="parinfer.js"></script>
<script src="js/compiled/parinfer-site.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$']],
      processClass: "mathjax",
      ignoreClass: "no-mathjax"
    }
  });
</script>
</body>
</html>
